;;; Model of Five-card draw Poker
;;;


(add-dm
    (goal isa game-state state get-scores)
)

(set-all-baselevels -100 10) ;; time offset and number of references


;; winning_scoresA is the hand strength of the model calculated by statistics
;; set the winning_scoresA passed by swift

(p wait-for-winningscores
    =goal>
        isa game-state
        state get-scores
        winning_scoresA =winning_scoresA
        cpu nil
==>
    +action>
        isa game-state
        winning_scoresA =winning_scoresA
    =goal>
        state set-scores
)

(p get-winningscores
    =goal>
        isa game-state
        state set-scores
        cpu nil
    =action>
        isa game-state
        winning_scoresA =winning_scoresA
==>
    =goal>
        state go
        winning_scoresA =winning_scoresA
)

;; initial raise(call) or fold decison

;;(p start-raise
;;    =goal>
;;        isa game-state
;;        state start
;;        cpu nil
;;==>
;;    =goal>
;;        cpu raise
;;)

;; retrieve game results

(p retrieve-pattern
    =goal>
        isa game-state
        cpu nil
        winning_scoresA =winning_scoresA
        state go
    =imaginal>
        isa  pattern
        winning_scoresA =winning_scoresA
        move nil
==>
    =goal>
        state retrieving
    +partial>
        isa  pattern
        winning_scoresA =winning_scoresA
)

;; select the move

(p select-move
    =goal>
        isa game-state
        state retrieving
    =imaginal>
        isa  pattern
        winning_scoresA =winning_scoresA
        move nil
    =partial>
        isa  pattern
        winning_scoresA =winning_scoresA
        move =move3
==>
    =goal>
        cpu  =move3
)

;; if retrieval fails, let the swift decide

(p take-action-retrieval-failure
    =goal>
        isa  game-state
        state retrieving
    ?partial>
        state  error
==>
    +action>
        isa game-state
        cpu nil
    =goal>
        isa wait
)

;; take actions, pass to swift

(p take-action
    =goal>
        isa game-state
        cpu =move
==>
    +action>
        isa game-state
        cpu =move
    =goal>
        isa wait
)

;; get feedback for the first run and unsuccessful retrieval, the winning score with pattern is recorded

(p feedback-start
    =goal>
        isa wait
        winning_scoresA =winning_scoresA
    =action>
        isa game-state
        cpu =cpu
==>
    +goal>
        isa game-state
        state get-scores
        cpu nil
        winning_scoresA nil
    +imaginal>
        isa pattern
        winning_scoresA =winning_scoresA
        move =cpu
)

(goal-focus goal)
